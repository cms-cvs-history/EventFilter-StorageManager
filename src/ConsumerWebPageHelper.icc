// $Id: ConsumerWebPageHelper.icc,v 1.1.2.5 2011/02/04 13:57:45 mommsen Exp $
/// @file: ConsumerWebPageHelper.icc

#include "EventFilter/StorageManager/interface/DQMConsumerMonitorCollection.h"
#include "EventFilter/StorageManager/interface/DQMEventMonitorCollection.h"
#include "EventFilter/StorageManager/interface/EventConsumerMonitorCollection.h"
#include "EventFilter/StorageManager/interface/XHTMLMonitor.h"

namespace stor
{

  template<typename EventQueueCollection_t, typename StatisticsReporter_t>
  ConsumerWebPageHelper<EventQueueCollection_t, StatisticsReporter_t>::
  ConsumerWebPageHelper
  (
    xdaq::ApplicationDescriptor* appDesc,
    const std::string& cvsVersion
  ) :
  WebPageHelper(appDesc, cvsVersion)
  {}
  
  template<typename EventQueueCollection_t, typename StatisticsReporter_t>
  void ConsumerWebPageHelper<EventQueueCollection_t, StatisticsReporter_t>::
  consumerStatistics
  (
    xgi::Output* out,
    const std::string& externallyVisibleState,
    const std::string& innerStateName,
    const std::string& errorMsg,
    boost::shared_ptr<StatisticsReporter_t> statisticsReporter,
    RegistrationCollectionPtr registrationCollection,
    boost::shared_ptr<EventQueueCollection_t> eventQueueCollection,
    DQMEventQueueCollectionPtr dqmEventQueueCollection
  )
  {
    // Get lock, initialize maker:
    XHTMLMonitor theMonitor;
    XHTMLMaker maker;
    
    // Create the body with the standard header
    XHTMLMaker::Node* body = createWebPageBody(maker, "Consumer Statistics", 
      externallyVisibleState, innerStateName, errorMsg);
    
    addDOMforEventConsumers(maker, body,
      registrationCollection,
      eventQueueCollection,
      statisticsReporter->getEventConsumerMonitorCollection()
    );
    
    maker.addNode("hr", body);
    
    addDOMforDQMEventConsumers(maker, body,
      registrationCollection,
      dqmEventQueueCollection,
      statisticsReporter->getDQMConsumerMonitorCollection()
    );
    
    addDOMforHyperLinks(maker, body);
    
    // Dump the webpage to the output stream
    maker.out(*out);
  }

  
  template<typename EventQueueCollection_t, typename StatisticsReporter_t>
  void ConsumerWebPageHelper<EventQueueCollection_t, StatisticsReporter_t>::
  addDOMforEventConsumers
  (
    XHTMLMaker& maker,
    XHTMLMaker::Node *parent,
    RegistrationCollectionPtr registrationCollection,
    boost::shared_ptr<EventQueueCollection_t> eventQueueCollection,
    const EventConsumerMonitorCollection& eventConsumerCollection
  )
  {
    RegistrationCollection::ConsumerRegistrations consumers;
    registrationCollection->getEventConsumers(consumers);
    
    
    XHTMLMaker::Node* table = maker.addNode("table", parent, _tableAttr);
    
    XHTMLMaker::Node* tableRow = maker.addNode("tr", table, _rowAttr);
    
    XHTMLMaker::AttrMap colspanAttr;
    colspanAttr[ "colspan" ] = "23";
    XHTMLMaker::Node* tableDiv = maker.addNode("th", tableRow, colspanAttr);
    maker.addText(tableDiv, "Consumer Statistics");
    
    XHTMLMaker::AttrMap rowspanAttr;
    rowspanAttr[ "rowspan" ] = "2";
    
    XHTMLMaker::AttrMap subColspanAttr;
    subColspanAttr[ "colspan" ] = "2";
    
    //Header
    tableRow = maker.addNode("tr", table, _specialRowAttr);
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Name");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Consumer Host" );
    // tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    // maker.addText(tableDiv, "Max Request Rate (Hz)");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Last Request Seconds Ago");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "HLT Output Module");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Filters");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Prescale");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Unique Events");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Enquing Policy");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Queue Size");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Events In Queue");
    
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Enqueued Event Rate (Hz)");
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Dropped Events");
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Served Event Rate (Hz)");
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Events Served");
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Average Event Size (kB)");
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Bandwidth (kB/s)");
    
    tableRow = maker.addNode("tr", table, _specialRowAttr);
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    
    if ( consumers.empty() )
    {
      XHTMLMaker::AttrMap messageAttr = colspanAttr;
      messageAttr[ "align" ] = "center";
      
      tableRow = maker.addNode("tr", table, _rowAttr);
      tableDiv = maker.addNode("td", tableRow, messageAttr);
      maker.addText(tableDiv, "No event consumers have registered yet.");
      return;
    }
    
    // Loop over consumers
    bool evenRow = false;
    XHTMLMaker::AttrMap tableLabelAttr = _tableLabelAttr;
    XHTMLMaker::AttrMap tableValueAttr = _tableValueAttr;
    utils::time_point_t now = utils::getCurrentTime();
    
    for( RegistrationCollection::ConsumerRegistrations::const_iterator
           it = consumers.begin(), itEnd = consumers.end();
         it != itEnd; ++it )
    {
      // Row:
      XHTMLMaker::AttrMap rowAttr = _rowAttr;
      if( evenRow )
      {
        rowAttr[ "style" ] = "background-color:#e0e0e0;";
        evenRow = false;
      }
      else
      {
        evenRow = true;
      }
      tableRow = maker.addNode("tr", table, rowAttr);
      
      // Name:
      tableDiv = maker.addNode("td", tableRow, _tableLabelAttr);
      maker.addText(tableDiv, (*it)->consumerName());
      
      // Host:
      tableDiv = maker.addNode("td", tableRow, _tableLabelAttr);
      maker.addText(tableDiv, (*it)->remoteHost());
      
      // Max request rate:
      // tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      // const utils::duration_t& interval = 
      //   (*it)->minEventRequestInterval();
      // if ( interval.is_not_a_date_time() )
      //   maker.addText(tableDiv, "n/a");
      // else
      //   maker.addDouble(tableDiv, 1 / utils::duration_to_seconds(interval), 1);
      
      // Status:
      if( (*it)->isStale(now) )
      {
        XHTMLMaker::AttrMap statusAttr = _tableValueAttr;
        statusAttr[ "style" ] = "color:brown;";
        tableDiv = maker.addNode("td", tableRow, statusAttr);
        maker.addText(tableDiv, "Stale");
      }
      else
      {
        tableDiv = maker.addNode("td", tableRow, tableValueAttr);
        maker.addDouble(tableDiv, (*it)->lastContactSecondsAgo(now), 1);
      }
      
      // Handle the case of consumers sharing a queue
      // If the previous consumer shared the queue, nothing more 
      // has to be printed.
      if ( it != consumers.begin() &&
        (*(it-1))->queueId() == (*it)->queueId() )
        continue;
      
      // Check how many consumers follow which share the same queue
      unsigned int count = 1;
      while ( (it+count) != itEnd &&
        (*(it+count))->queueId() == (*it)->queueId() ) ++count;
      std::ostringstream str;
      str << count;
      tableLabelAttr[ "rowspan" ] = str.str();
      tableValueAttr[ "rowspan" ] = str.str();
      
      // HLT output module:
      tableDiv = maker.addNode("td", tableRow, tableLabelAttr);
      maker.addText(tableDiv, (*it)->outputModuleLabel());
      
      // Filter list:
      std::string filters = (*it)->triggerSelection();
      if ( filters.empty() )
      {
        const Strings fl = (*it)->eventSelection();
        for( Strings::const_iterator
               lit = fl.begin(), litEnd = fl.end();
             lit != litEnd; ++lit )
        {
          if( lit != fl.begin() ) filters += "  ";
          filters += *lit;
        }
      }
      tableDiv = maker.addNode("td", tableRow, tableLabelAttr);
      maker.addText(tableDiv, filters);
      
      // Prescale:
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addInt(tableDiv, (*it)->prescale());
      
      // Unique events:
      tableDiv = maker.addNode("td", tableRow, tableLabelAttr);
      maker.addBool(tableDiv, (*it)->uniqueEvents());
      
      // Policy:
      std::ostringstream policy;
      policy << (*it)->queuePolicy();
      tableDiv = maker.addNode("td", tableRow, tableLabelAttr);
      maker.addText(tableDiv, policy.str());
      
      // Queue size:
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addInt(tableDiv, (*it)->queueSize());
    
      // Events in queue:
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addInt(tableDiv, eventQueueCollection->size( (*it)->queueId() ));
      
      // Events enqueued:
      MonitoredQuantity::Stats enqueuedStats;
      const bool enqueuedFound = eventConsumerCollection.getQueued( (*it)->queueId(), enqueuedStats );
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        enqueuedFound ? enqueuedStats.getSampleRate(MonitoredQuantity::FULL) : 0
      );
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        enqueuedFound ? enqueuedStats.getSampleRate(MonitoredQuantity::RECENT) : 0
      );
      
      // Dropped Events:
      MonitoredQuantity::Stats droppedStats;
      const bool droppedFound = eventConsumerCollection.getDropped( (*it)->queueId(), droppedStats );
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        droppedFound ? droppedStats.getValueSum(MonitoredQuantity::FULL) : 0, 0
      );
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        droppedFound ? droppedStats.getValueSum(MonitoredQuantity::RECENT) : 0, 0
      );
      
      // Events served:
      MonitoredQuantity::Stats servedStats;
      const bool servedFound = eventConsumerCollection.getServed( (*it)->queueId(), servedStats );
      
      // rate
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getSampleRate(MonitoredQuantity::FULL) : 0
      );
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getSampleRate(MonitoredQuantity::RECENT) : 0
      );
      
      // event counts
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addInt(tableDiv,
        servedFound ? servedStats.getSampleCount(MonitoredQuantity::FULL) : 0
      );
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addInt(tableDiv,
        servedFound ? servedStats.getSampleCount(MonitoredQuantity::RECENT) : 0
      );
      
      // event size
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getValueAverage(MonitoredQuantity::FULL)/1024 : 0,
        1);
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getValueAverage(MonitoredQuantity::RECENT)/1024 : 0,
        1);
      
      // bandwidth
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getValueRate(MonitoredQuantity::FULL)/1024 : 0
      );
      tableDiv = maker.addNode("td", tableRow, tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getValueRate(MonitoredQuantity::RECENT)/1024 : 0
      );
    }
  }
  
  
  template<typename EventQueueCollection_t, typename StatisticsReporter_t>
  void ConsumerWebPageHelper<EventQueueCollection_t, StatisticsReporter_t>::
  addDOMforDQMEventConsumers
  (
    XHTMLMaker& maker,
    XHTMLMaker::Node *parent,
    RegistrationCollectionPtr registrationCollection,
    DQMEventQueueCollectionPtr dqmEventQueueCollection,
    const DQMConsumerMonitorCollection& dqmConsumerCollection
  )
  {
    RegistrationCollection::DQMConsumerRegistrations consumers;
    registrationCollection->getDQMEventConsumers( consumers );
    
    
    XHTMLMaker::Node* table = maker.addNode("table", parent, _tableAttr);
    
    XHTMLMaker::Node* tableRow = maker.addNode("tr", table, _rowAttr);
    
    XHTMLMaker::AttrMap colspanAttr;
    colspanAttr[ "colspan" ] = "20";
    XHTMLMaker::Node* tableDiv = maker.addNode("th", tableRow, colspanAttr);
    maker.addText(tableDiv, "DQM Consumer Statistics");
    
    XHTMLMaker::AttrMap rowspanAttr;
    rowspanAttr[ "rowspan" ] = "2";
    
    XHTMLMaker::AttrMap subColspanAttr;
    subColspanAttr[ "colspan" ] = "2";
    
    //Header
    tableRow = maker.addNode("tr", table, _specialRowAttr);
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Name");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Consumer Host" );
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Status");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Top Level Folder");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Enquing Policy");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Queue Size");
    tableDiv = maker.addNode("th", tableRow, rowspanAttr);
    maker.addText(tableDiv, "Events In Queue");
    
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Enqueued Event Rate (Hz)");
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Served Event Rate (Hz)");
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Events Served");
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Average Event Size (kB)");
    tableDiv = maker.addNode("th", tableRow, subColspanAttr);
    maker.addText(tableDiv, "Bandwidth (kB/s)");
    
    tableRow = maker.addNode("tr", table, _specialRowAttr);
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "overall");
    tableDiv = maker.addNode("th", tableRow);
    maker.addText(tableDiv, "recent");
    
    if ( consumers.empty() )
    {
      XHTMLMaker::AttrMap messageAttr = colspanAttr;
      messageAttr[ "align" ] = "center";
      
      tableRow = maker.addNode("tr", table, _rowAttr);
      tableDiv = maker.addNode("td", tableRow, messageAttr);
      maker.addText(tableDiv, "No DQM consumers have registered yet.");
    return;
    }
    
    // Loop over consumers
    bool evenRow = false;
    utils::time_point_t now = utils::getCurrentTime();
    
    for( RegistrationCollection::DQMConsumerRegistrations::const_iterator
           it = consumers.begin(), itEnd = consumers.end();
         it != itEnd; ++it )
    {
      // Row:
      XHTMLMaker::AttrMap rowAttr = _rowAttr;
      if( evenRow )
      {
        rowAttr[ "style" ] = "background-color:#e0e0e0;";
        evenRow = false;
      }
      else
      {
        evenRow = true;
      }
      tableRow = maker.addNode("tr", table, rowAttr);
      
      // Name:
      tableDiv = maker.addNode("td", tableRow, _tableLabelAttr);
      maker.addText(tableDiv, (*it)->consumerName());
      
      // Host:
      tableDiv = maker.addNode("td", tableRow, _tableLabelAttr);
      maker.addText(tableDiv, (*it)->remoteHost());
      
      // Status:
      XHTMLMaker::AttrMap statusAttr = _tableLabelAttr;
      std::string statusMessage;
      if( (*it)->isStale(now) )
      {
        statusAttr[ "style" ] = "color:brown;";
        statusMessage = "Stale";
      }
      else
      {
        statusAttr[ "style" ] = "color:green;";
      statusMessage = "Active";
      }
      tableDiv = maker.addNode("td", tableRow, statusAttr);
      maker.addText(tableDiv, statusMessage);
      
      // Top level folder:
      tableDiv = maker.addNode("td", tableRow, statusAttr);
      maker.addText(tableDiv, (*it)->topLevelFolderName());
      
      // Policy:
      std::ostringstream policy;
      policy << (*it)->queuePolicy();
      tableDiv = maker.addNode("td", tableRow, _tableLabelAttr);
      maker.addText(tableDiv, policy.str());
      
      // Queue size:
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addInt(tableDiv, (*it)->queueSize());
      
      // Events in queue:
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addInt(tableDiv, dqmEventQueueCollection->size( (*it)->queueId() ));
      
      // Events enqueued:
      MonitoredQuantity::Stats enqueuedStats;
      const bool enqueuedFound = dqmConsumerCollection.getQueued( (*it)->queueId(), enqueuedStats );
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addDouble(tableDiv,
        enqueuedFound ? enqueuedStats.getSampleRate(MonitoredQuantity::FULL) : 0
      );
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addDouble(tableDiv,
        enqueuedFound ? enqueuedStats.getSampleRate(MonitoredQuantity::RECENT) : 0
      );
      
      // Events served:
      MonitoredQuantity::Stats servedStats;
      const bool servedFound = dqmConsumerCollection.getServed( (*it)->queueId(), servedStats );
      
      // rate
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getSampleRate(MonitoredQuantity::FULL) : 0
      );
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getSampleRate(MonitoredQuantity::RECENT) : 0
      );
      
      // event counts
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addInt(tableDiv,
        servedFound ? servedStats.getSampleCount(MonitoredQuantity::FULL) : 0
      );
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addInt(tableDiv,
        servedFound ? servedStats.getSampleCount(MonitoredQuantity::RECENT) : 0
      );
      
      // event size
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getValueAverage(MonitoredQuantity::FULL)/1024 : 0,
        1);
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getValueAverage(MonitoredQuantity::RECENT)/1024 : 0,
        1);
      
      // bandwidth
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getValueRate(MonitoredQuantity::FULL)/1024 : 0
      );
      tableDiv = maker.addNode("td", tableRow, _tableValueAttr);
      maker.addDouble(tableDiv,
        servedFound ? servedStats.getValueRate(MonitoredQuantity::RECENT)/1024 : 0
      );
    }
  }

} // namespace stor


/// emacs configuration
/// Local Variables: -
/// mode: c++ -
/// c-basic-offset: 2 -
/// indent-tabs-mode: nil -
/// End: -
