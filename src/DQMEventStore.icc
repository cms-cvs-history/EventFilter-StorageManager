// $Id: DQMEventStore.icc,v 1.12.2.2 2011/02/23 09:26:39 mommsen Exp $
/// @file: DQMEventStore.icc

#include "TROOT.h"
#include "TTimeStamp.h"

#include "EventFilter/StorageManager/interface/DQMEventMonitorCollection.h"
#include "EventFilter/StorageManager/interface/DQMEventStore.h"
#include "EventFilter/StorageManager/interface/I2OChain.h"
#include "EventFilter/StorageManager/interface/QueueID.h"
#include "EventFilter/StorageManager/interface/StatisticsReporter.h"
#include "EventFilter/StorageManager/interface/Utils.h"


namespace stor {
    
  template<class EventType, class ConnectionType>  
  DQMEventStore<EventType,ConnectionType>::
  DQMEventStore
  (
    DQMEventMonitorCollection& dqmEventMonColl,
    ConnectionType* connectionType,
    size_t (ConnectionType::*getExpectedUpdatesCount)() const
  ) :
  _dqmEventMonColl(dqmEventMonColl),
  _connectionType(connectionType),
  _getExpectedUpdatesCount(getExpectedUpdatesCount)
  {
    gROOT->SetBatch(kTRUE);
  }

  template<class EventType, class ConnectionType>  
  DQMEventStore<EventType,ConnectionType>::
  ~DQMEventStore()
  {
    clear();
  }

  template<class EventType, class ConnectionType>  
  void
  DQMEventStore<EventType,ConnectionType>::
  clear()
  {
    _store.clear();
    while ( ! _topLevelFoldersReadyToServe.empty() )
      _topLevelFoldersReadyToServe.pop();
    _tempEventArea.clear();
  }
  
  template<class EventType, class ConnectionType>  
  void
  DQMEventStore<EventType,ConnectionType>::
  purge()
  {
    addReadyTopLevelFoldersToReadyToServe();
    _store.clear();
  }
  
  template<class EventType, class ConnectionType>  
  void
  DQMEventStore<EventType,ConnectionType>::
  setParameters(DQMProcessingParams const& dqmParams)
  {
    clear();
    _dqmParams = dqmParams;
  }
  
  template<class EventType, class ConnectionType>  
  void
  DQMEventStore<EventType,ConnectionType>::
  addDQMEvent(EventType const& dqmEvent)
  {
    if ( _dqmParams._collateDQM )
      addDQMEventToStore(dqmEvent);
    else
      addDQMEventToReadyToServe(dqmEvent);
  }
  
  template<class EventType, class ConnectionType>  
  bool
  DQMEventStore<EventType,ConnectionType>::
  getCompletedTopLevelFolderIfAvailable
  (
    DQMTopLevelFolder::Record& record
  )
  {
    if ( _topLevelFoldersReadyToServe.empty() ) return false;
    
    record = _topLevelFoldersReadyToServe.front();
    _topLevelFoldersReadyToServe.pop();
    
    return true;
  }
  
  template<class EventType, class ConnectionType>  
  void
  DQMEventStore<EventType,ConnectionType>::
  addDQMEventToStore(EventType const& dqmEvent)
  {
    const DQMKey newKey = dqmEvent.dqmKey();
    
    // Use efficientAddOrUpdates pattern suggested by Item 24 of 
    
    // 'Effective STL' by Scott Meyers
    DQMTopLevelFolderMap::iterator pos = _store.lower_bound(newKey);
    
    if(pos == _store.end() || (_store.key_comp()(newKey, pos->first)))
    {
      // Use pos as a hint to insert a new record, so it can avoid another lookup
      DQMTopLevelFolderPtr topLevelFolder( new DQMTopLevelFolder(
          dqmEvent.dqmKey(), dqmEvent.getDQMEventConsumerTags(),
          _dqmParams, _dqmEventMonColl, 
          (_connectionType->*_getExpectedUpdatesCount)()
        ));
      pos = _store.insert(pos, DQMTopLevelFolderMap::value_type(newKey, topLevelFolder));
    }
    pos->second->addDQMEvent(getDQMEventView(dqmEvent));

    addReadyTopLevelFoldersToReadyToServe();
  }
  
  template<class EventType, class ConnectionType>  
  void
  DQMEventStore<EventType,ConnectionType>::
  addDQMEventToReadyToServe(EventType const& dqmEvent)
  {
    DQMTopLevelFolderPtr topLevelFolder( new DQMTopLevelFolder(
        dqmEvent.dqmKey(), dqmEvent.getDQMEventConsumerTags(),
        _dqmParams, _dqmEventMonColl, 1));
    topLevelFolder->addDQMEvent(getDQMEventView(dqmEvent));
    addTopLevelFolderToReadyToServe(topLevelFolder);
  }
  
  template<class EventType, class ConnectionType>  
  void
  DQMEventStore<EventType,ConnectionType>::
  addReadyTopLevelFoldersToReadyToServe()
  {
    DQMTopLevelFolderPtr topLevelFolder;
    
    while ( getNextReadyTopLevelFolder(topLevelFolder) )
    {
      addTopLevelFolderToReadyToServe(topLevelFolder);
    }
  }
  
  template<class EventType, class ConnectionType>  
  void
  DQMEventStore<EventType,ConnectionType>::
  addTopLevelFolderToReadyToServe(const DQMTopLevelFolderPtr topLevelFolder)
  {
    DQMTopLevelFolder::Record record;
    topLevelFolder->getRecord(record);
    _topLevelFoldersReadyToServe.push(record);
  }
  
  template<class EventType, class ConnectionType>  
  bool
  DQMEventStore<EventType,ConnectionType>::
  getNextReadyTopLevelFolder(DQMTopLevelFolderPtr& topLevelFolder)
  {
    utils::time_point_t now = utils::getCurrentTime();
    
    DQMTopLevelFolderMap::iterator it = _store.begin();
    DQMTopLevelFolderMap::const_iterator itEnd = _store.end();
    while ( it !=  itEnd && ! it->second->isReady(now) ) ++it;
    
    if ( it == itEnd ) return false;
    
    topLevelFolder = it->second;
    _store.erase(it);
    return true;
  }

} // namespace stor


/// emacs configuration
/// Local Variables: -
/// mode: c++ -
/// c-basic-offset: 2 -
/// indent-tabs-mode: nil -
/// End: -
