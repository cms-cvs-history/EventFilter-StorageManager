// $Id: DQMEventStore.icc,v 1.1.2.1 2011/02/27 13:56:41 mommsen Exp $
/// @file: DQMEventStore.icc

#include "TROOT.h"
#include "TTimeStamp.h"

#include "toolbox/task/WorkLoopFactory.h"

#include "EventFilter/StorageManager/interface/DQMEventMonitorCollection.h"
#include "EventFilter/StorageManager/interface/DQMEventStore.h"
#include "EventFilter/StorageManager/interface/I2OChain.h"
#include "EventFilter/StorageManager/interface/QueueID.h"
#include "EventFilter/StorageManager/interface/StatisticsReporter.h"
#include "EventFilter/StorageManager/interface/Utils.h"


namespace stor {
    
  template<class EventType, class ConnectionType, class StateMachineType>  
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  DQMEventStore
  (
    xdaq::ApplicationDescriptor* appDescriptor,
    DQMEventQueueCollectionPtr dqmEventQueueCollection,
    DQMEventMonitorCollection& dqmEventMonColl,
    ConnectionType* connectionType,
    size_t (ConnectionType::*getExpectedUpdatesCount)() const,
    StateMachineType* stateMachineType,
    void (StateMachineType::*moveToFailedState)(xcept::Exception&)
  ) :
  _appDescriptor(appDescriptor),
  _dqmEventQueueCollection(dqmEventQueueCollection),
  _dqmEventMonColl(dqmEventMonColl),
  _connectionType(connectionType),
  _getExpectedUpdatesCount(getExpectedUpdatesCount),
  _stateMachineType(stateMachineType),
  _moveToFailedState(moveToFailedState),
  _processCompletedTopLevelFolders(false)
  {
    gROOT->SetBatch(kTRUE);
    startWorkLoop();
  }

  template<class EventType, class ConnectionType, class StateMachineType>  
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  ~DQMEventStore()
  {
    clear();
  }

  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  clear()
  {
    boost::mutex::scoped_lock sl(_storeMutex);
    _store.clear();
    _processCompletedTopLevelFolders = false;
    _tempEventArea.clear();
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  purge()
  {
    _processCompletedTopLevelFolders = false;
    while ( handleNextCompletedTopLevelFolder() ) {}
    boost::mutex::scoped_lock sl(_storeMutex);
    _store.clear();
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  setParameters(DQMProcessingParams const& dqmParams)
  {
    clear();
    _dqmParams = dqmParams;
    _processCompletedTopLevelFolders = true;
    _completedFolderWL->submit(_completedFolderAction);
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  addDQMEvent(EventType const& dqmEvent)
  {
    if ( _dqmParams._collateDQM )
      addDQMEventToStore(dqmEvent);
    else
      addDQMEventToReadyToServe(dqmEvent);
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  addDQMEventToStore(EventType const& dqmEvent)
  {
    const DQMKey newKey = dqmEvent.dqmKey();
    
    boost::mutex::scoped_lock sl(_storeMutex);
    DQMTopLevelFolderMap::iterator pos = _store.lower_bound(newKey);
    
    if(pos == _store.end() || (_store.key_comp()(newKey, pos->first)))
    {
      // Use pos as a hint to insert a new record, so it can avoid another lookup
      DQMTopLevelFolderPtr topLevelFolder( new DQMTopLevelFolder(
          newKey, dqmEvent.getDQMEventConsumerTags(),
          _dqmParams, _dqmEventMonColl, 
          (_connectionType->*_getExpectedUpdatesCount)()
        ));
      pos = _store.insert(pos, DQMTopLevelFolderMap::value_type(newKey, topLevelFolder));
    }
    pos->second->addDQMEvent(getDQMEventView(dqmEvent));
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  addDQMEventToReadyToServe(EventType const& dqmEvent)
  {
    const DQMKey newKey = dqmEvent.dqmKey();

    DQMTopLevelFolderPtr topLevelFolder( new DQMTopLevelFolder(
        newKey, dqmEvent.getDQMEventConsumerTags(),
        _dqmParams, _dqmEventMonColl, 1));
    topLevelFolder->addDQMEvent(getDQMEventView(dqmEvent));

    boost::mutex::scoped_lock sl(_storeMutex);
    _store.insert(DQMTopLevelFolderMap::value_type(newKey, topLevelFolder));
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  bool
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  getNextReadyTopLevelFolder(DQMTopLevelFolderPtr& topLevelFolder)
  {
    boost::mutex::scoped_lock sl(_storeMutex);
    utils::time_point_t now = utils::getCurrentTime();
    
    DQMTopLevelFolderMap::iterator it = _store.begin();
    DQMTopLevelFolderMap::const_iterator itEnd = _store.end();
    while ( it !=  itEnd && ! it->second->isReady(now) ) ++it;
    
    if ( it == itEnd ) return false;
    
    topLevelFolder = it->second;
    _store.erase(it);
    return true;
  }
  

  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  startWorkLoop()
  {
    try
    {
      std::string identifier = utils::getIdentifier(_appDescriptor);
    
      _completedFolderWL = toolbox::task::getWorkLoopFactory()->
        getWorkLoop( identifier + "CompletedFolderWL", "waiting" );
    
      if ( ! _completedFolderWL->isActive() )
      {
        _completedFolderWL->activate();
      }

      _completedFolderAction = 
          toolbox::task::bind(this,
            &DQMEventStore<EventType,ConnectionType,StateMachineType>::
            processCompletedTopLevelFolders,
            identifier + "CompletedFolder");
    }
    catch (xcept::Exception& e)
    {
      std::string msg = "Failed to start workloop 'CompletedFolderWL'.";
      XCEPT_RETHROW(exception::DQMEventProcessing, msg, e);
    }
  }
  
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  bool
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  processCompletedTopLevelFolders(toolbox::task::WorkLoop*)
  {
    std::string errorMsg = "Failed to send completed top level folders to consumers: ";

    ::sleep(5);

    try
    {
      while (
        _processCompletedTopLevelFolders &&
        handleNextCompletedTopLevelFolder()
      ) {}
    }
    catch(xcept::Exception &e)
    {
      XCEPT_DECLARE_NESTED(exception::DQMEventProcessing,
        sentinelException, errorMsg, e );
      (_stateMachineType->*_moveToFailedState)(sentinelException);
    }
    catch(std::exception &e)
    {
      errorMsg += e.what();
      XCEPT_DECLARE(exception::DQMEventProcessing,
        sentinelException, errorMsg );
      (_stateMachineType->*_moveToFailedState)(sentinelException);
    }
    catch(...)
    {
      errorMsg += "Unknown exception";
      XCEPT_DECLARE(exception::DQMEventProcessing,
        sentinelException, errorMsg );
      (_stateMachineType->*_moveToFailedState)(sentinelException);
    }
    
    return _processCompletedTopLevelFolders;
  }
  
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  bool
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  handleNextCompletedTopLevelFolder()
  {
    DQMTopLevelFolderPtr topLevelFolder;
    if ( getNextReadyTopLevelFolder(topLevelFolder) )
    {
      DQMTopLevelFolder::Record record;
      topLevelFolder->getRecord(record);
      _dqmEventQueueCollection->addEvent(record);
      return true;
    }

    return false;
  }

} // namespace stor


/// emacs configuration
/// Local Variables: -
/// mode: c++ -
/// c-basic-offset: 2 -
/// indent-tabs-mode: nil -
/// End: -
