<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>StorageManager: src/RollingSampleCounter.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>src/RollingSampleCounter.cc</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00005"></a>00005 <span class="preprocessor">#include "EventFilter/StorageManager/interface/RollingSampleCounter.h"</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="keyword">using namespace </span>stor;
<a name="l00008"></a>00008 
<a name="l00012"></a>00012 RollingSampleCounter::
<a name="l00013"></a>00013 RollingSampleCounter(<span class="keywordtype">int</span> windowSize, <span class="keywordtype">int</span> binSize, <span class="keywordtype">int</span> validSubWindowSize,
<a name="l00014"></a>00014                      AccumulationStyle style):
<a name="l00015"></a>00015   accumStyle_(style),
<a name="l00016"></a>00016   sampleCount_(0),
<a name="l00017"></a>00017   processedBinCount_(0),
<a name="l00018"></a>00018   workingBinSum_(0.0),
<a name="l00019"></a>00019   workingBinStartTime_(0.0),
<a name="l00020"></a>00020   currentTotal_(0.0)
<a name="l00021"></a>00021 {
<a name="l00022"></a>00022   <span class="comment">// provide a reasonable default for the window size, if needed</span>
<a name="l00023"></a>00023   <span class="keywordflow">if</span> (windowSize &lt;= 0) {
<a name="l00024"></a>00024     this-&gt;windowSize_ = 100;  <span class="comment">// 100 samples</span>
<a name="l00025"></a>00025   }
<a name="l00026"></a>00026   <span class="keywordflow">else</span> {
<a name="l00027"></a>00027     this-&gt;windowSize_ = windowSize;
<a name="l00028"></a>00028   }
<a name="l00029"></a>00029 
<a name="l00030"></a>00030   <span class="comment">// provide a reasonable default for the bin size, if needed</span>
<a name="l00031"></a>00031   <span class="keywordflow">if</span> (binSize &lt;= 0) {
<a name="l00032"></a>00032     this-&gt;binSize_ = this-&gt;windowSize_;
<a name="l00033"></a>00033   }
<a name="l00034"></a>00034   <span class="keywordflow">else</span> {
<a name="l00035"></a>00035     this-&gt;binSize_ = binSize;
<a name="l00036"></a>00036   }
<a name="l00037"></a>00037 
<a name="l00038"></a>00038   <span class="comment">// determine the bin count from the window and bin sizes</span>
<a name="l00039"></a>00039   <span class="keywordflow">if</span> (this-&gt;windowSize_ &gt; 0 &amp;&amp; this-&gt;binSize_ &gt; 0) {
<a name="l00040"></a>00040     this-&gt;binCount_ =
<a name="l00041"></a>00041       (int) (0.5 + ((<span class="keywordtype">double</span>) this-&gt;windowSize_ / (<span class="keywordtype">double</span>) this-&gt;binSize_));
<a name="l00042"></a>00042     <span class="keywordflow">if</span> (this-&gt;binCount_ &lt; 1) {
<a name="l00043"></a>00043       this-&gt;binCount_ = 1;
<a name="l00044"></a>00044     }
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="comment">// recalculate the window size to handle rounding</span>
<a name="l00047"></a>00047     this-&gt;windowSize_ = this-&gt;binCount_ * this-&gt;binSize_;
<a name="l00048"></a>00048   }
<a name="l00049"></a>00049   <span class="keywordflow">else</span> {
<a name="l00050"></a>00050     this-&gt;binCount_ = 1;
<a name="l00051"></a>00051   }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053   <span class="comment">// determine the number of bins needed for a valid result</span>
<a name="l00054"></a>00054   this-&gt;validBinCount_ =
<a name="l00055"></a>00055     (int) (0.5 + ((<span class="keywordtype">double</span>) validSubWindowSize / (double) this-&gt;binSize_));
<a name="l00056"></a>00056   <span class="keywordflow">if</span> (this-&gt;validBinCount_ &lt;= 0) {
<a name="l00057"></a>00057     this-&gt;validBinCount_ = 1;
<a name="l00058"></a>00058   }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   <span class="comment">// if working with data immediately, assume the first bin is good</span>
<a name="l00061"></a>00061   <span class="keywordflow">if</span> (this-&gt;accumStyle_ == INCLUDE_SAMPLES_IMMEDIATELY) {
<a name="l00062"></a>00062     processedBinCount_ = 1;
<a name="l00063"></a>00063   }
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   <span class="comment">// initialize times and bins</span>
<a name="l00066"></a>00066   this-&gt;workingBinId_ = getBinId(this-&gt;sampleCount_);
<a name="l00067"></a>00067   this-&gt;binStartTimes_.reset(<span class="keyword">new</span> std::vector&lt;double&gt;);
<a name="l00068"></a>00068   this-&gt;binStopTimes_.reset(<span class="keyword">new</span> std::vector&lt;double&gt;);
<a name="l00069"></a>00069   this-&gt;binContents_.reset(<span class="keyword">new</span> std::vector&lt;double&gt;);
<a name="l00070"></a>00070   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; this-&gt;binCount_; ++idx) {
<a name="l00071"></a>00071     this-&gt;binStartTimes_-&gt;push_back(0.0);
<a name="l00072"></a>00072     this-&gt;binStopTimes_-&gt;push_back(0.0);
<a name="l00073"></a>00073     this-&gt;binContents_-&gt;push_back(0.0);
<a name="l00074"></a>00074   }
<a name="l00075"></a>00075 }
<a name="l00076"></a>00076 
<a name="l00080"></a>00080 <span class="keywordtype">void</span> RollingSampleCounter::addSample(<span class="keywordtype">double</span> value, <span class="keywordtype">double</span> currentTime)
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082   boost::recursive_mutex::scoped_lock sl(dataMutex_);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="comment">// shuffle the bins so that they correctly reflect the sample window</span>
<a name="l00085"></a>00085   shuffleBins(sampleCount_);
<a name="l00086"></a>00086   ++sampleCount_;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   <span class="comment">// add the new sample to either the working sum or the current</span>
<a name="l00089"></a>00089   <span class="comment">// sum depending on the accumulation style</span>
<a name="l00090"></a>00090   <span class="keywordflow">if</span> (accumStyle_ == INCLUDE_SAMPLES_AFTER_BINNING) {
<a name="l00091"></a>00091     workingBinSum_ += value;
<a name="l00092"></a>00092     <span class="keywordflow">if</span> (sampleCount_ == 1) {
<a name="l00093"></a>00093       workingBinStartTime_ = currentTime;
<a name="l00094"></a>00094     }
<a name="l00095"></a>00095   }
<a name="l00096"></a>00096   <span class="keywordflow">else</span> {
<a name="l00097"></a>00097     <span class="keywordtype">int</span> binIndex = (int) (workingBinId_ % binCount_);
<a name="l00098"></a>00098     (*binContents_)[binIndex] += value;
<a name="l00099"></a>00099     currentTotal_ += value;
<a name="l00100"></a>00100     <span class="keywordflow">if</span> (sampleCount_ == 1) {
<a name="l00101"></a>00101       (*binStartTimes_)[binIndex] = currentTime;
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103     (*binStopTimes_)[binIndex] = currentTime;
<a name="l00104"></a>00104   }
<a name="l00105"></a>00105 }
<a name="l00106"></a>00106 
<a name="l00111"></a>00111 <span class="keywordtype">bool</span> RollingSampleCounter::hasValidResult()
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113   boost::recursive_mutex::scoped_lock sl(dataMutex_);
<a name="l00114"></a>00114 
<a name="l00115"></a>00115   <span class="keywordflow">return</span> (processedBinCount_ &gt;= validBinCount_);
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00122"></a>00122 <span class="keywordtype">int</span> RollingSampleCounter::getSampleCount()
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124   boost::recursive_mutex::scoped_lock sl(dataMutex_);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   <span class="keywordtype">int</span> result = windowSize_;
<a name="l00127"></a>00127   <span class="keywordflow">if</span> (sampleCount_ &lt; windowSize_) {
<a name="l00128"></a>00128     result = (int) sampleCount_;
<a name="l00129"></a>00129   }
<a name="l00130"></a>00130   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (accumStyle_ == INCLUDE_SAMPLES_IMMEDIATELY &amp;&amp; binSize_ &gt; 1) {
<a name="l00131"></a>00131     <span class="comment">// NEED TO FIX!!!</span>
<a name="l00132"></a>00132     result = 1 + (int) ((sampleCount_ - 1) % windowSize_);
<a name="l00133"></a>00133   }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135   <span class="keywordflow">return</span> result;
<a name="l00136"></a>00136 }
<a name="l00137"></a>00137 
<a name="l00143"></a>00143 <span class="keywordtype">double</span> RollingSampleCounter::getSampleRate(<span class="keywordtype">double</span> currentTime)
<a name="l00144"></a>00144 {
<a name="l00145"></a>00145   boost::recursive_mutex::scoped_lock sl(dataMutex_);
<a name="l00146"></a>00146 
<a name="l00147"></a>00147   <span class="keywordtype">double</span> duration = getDuration(currentTime);
<a name="l00148"></a>00148   <span class="keywordflow">if</span> (duration &gt; 0.0) {
<a name="l00149"></a>00149     <span class="keywordflow">return</span> ((<span class="keywordtype">double</span>) getSampleCount()) / duration;
<a name="l00150"></a>00150   }
<a name="l00151"></a>00151   <span class="keywordflow">else</span> {
<a name="l00152"></a>00152     <span class="keywordflow">return</span> 0.0;
<a name="l00153"></a>00153   }
<a name="l00154"></a>00154 }
<a name="l00155"></a>00155 
<a name="l00159"></a>00159 <span class="keywordtype">double</span> RollingSampleCounter::getValueSum() {
<a name="l00160"></a>00160   boost::recursive_mutex::scoped_lock sl(dataMutex_);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162   <span class="keywordflow">return</span> currentTotal_;
<a name="l00163"></a>00163 }
<a name="l00164"></a>00164 
<a name="l00169"></a>00169 <span class="keywordtype">double</span> RollingSampleCounter::getValueAverage()
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171   boost::recursive_mutex::scoped_lock sl(dataMutex_);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="keywordflow">if</span> (getSampleCount() &gt; 0) {
<a name="l00174"></a>00174     <span class="keywordflow">return</span> ((<span class="keywordtype">double</span>) currentTotal_) / ((double) getSampleCount());
<a name="l00175"></a>00175   }
<a name="l00176"></a>00176   <span class="keywordflow">else</span> {
<a name="l00177"></a>00177     <span class="keywordflow">return</span> 0.0;
<a name="l00178"></a>00178   }
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00187"></a>00187 <span class="keywordtype">double</span> RollingSampleCounter::getValueRate()
<a name="l00188"></a>00188 {
<a name="l00189"></a>00189   boost::recursive_mutex::scoped_lock sl(dataMutex_);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191   <span class="keywordtype">double</span> duration = getDuration();
<a name="l00192"></a>00192   <span class="keywordflow">if</span> (duration &gt; 0.0) {
<a name="l00193"></a>00193     <span class="keywordflow">return</span> ((<span class="keywordtype">double</span>) currentTotal_) / duration;
<a name="l00194"></a>00194   }
<a name="l00195"></a>00195   <span class="keywordflow">else</span> {
<a name="l00196"></a>00196     <span class="keywordflow">return</span> 0.0;
<a name="l00197"></a>00197   }
<a name="l00198"></a>00198 }
<a name="l00199"></a>00199 
<a name="l00211"></a>00211 <span class="keywordtype">double</span> RollingSampleCounter::getDuration(<span class="keywordtype">double</span> currentTime)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213   boost::recursive_mutex::scoped_lock sl(dataMutex_);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215   <span class="comment">//if (processedBinCount_ &lt; 1 || ! hasValidResult()) {</span>
<a name="l00216"></a>00216   <span class="keywordflow">if</span> (! hasValidResult()) {
<a name="l00217"></a>00217     <span class="keywordflow">return</span> 0.0;
<a name="l00218"></a>00218   }
<a name="l00219"></a>00219   <span class="keywordflow">else</span> {
<a name="l00220"></a>00220     <span class="keywordtype">int</span> actualBinCount = binCount_;
<a name="l00221"></a>00221     <span class="keywordflow">if</span> (processedBinCount_ &lt; binCount_) {
<a name="l00222"></a>00222       actualBinCount = (int) processedBinCount_;
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224     <span class="keywordtype">long</span> <span class="keywordtype">long</span> startBinId = workingBinId_ - actualBinCount;
<a name="l00225"></a>00225     <span class="keywordtype">long</span> <span class="keywordtype">long</span> stopBinId = workingBinId_ - 1;
<a name="l00226"></a>00226     <span class="keywordflow">if</span> (accumStyle_ == RollingSampleCounter::INCLUDE_SAMPLES_IMMEDIATELY) {
<a name="l00227"></a>00227       ++startBinId;
<a name="l00228"></a>00228       ++stopBinId;
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     <span class="keywordtype">int</span> startBinIndex = (int) (startBinId % binCount_);
<a name="l00232"></a>00232     <span class="keywordtype">int</span> stopBinIndex = (int) (stopBinId % binCount_);
<a name="l00233"></a>00233 
<a name="l00234"></a>00234     <span class="keywordflow">if</span> ((*binStopTimes_)[stopBinIndex] &gt; 0.0 &amp;&amp;
<a name="l00235"></a>00235         (*binStartTimes_)[startBinIndex] &gt; 0.0) {
<a name="l00236"></a>00236       <span class="keywordflow">if</span> (currentTime &lt;= 0.0) {
<a name="l00237"></a>00237         <span class="keywordflow">return</span> ((*binStopTimes_)[stopBinIndex] -
<a name="l00238"></a>00238                 (*binStartTimes_)[startBinIndex]);
<a name="l00239"></a>00239       }
<a name="l00240"></a>00240       <span class="keywordflow">else</span> {
<a name="l00241"></a>00241         <span class="keywordflow">return</span> (currentTime - (*binStartTimes_)[startBinIndex]);
<a name="l00242"></a>00242       }
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244     <span class="keywordflow">else</span> {
<a name="l00245"></a>00245       <span class="keywordflow">return</span> 0.0;
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247   }
<a name="l00248"></a>00248 }
<a name="l00249"></a>00249 
<a name="l00253"></a>00253 <span class="keywordtype">void</span> RollingSampleCounter::dumpData(std::ostream&amp; outStream)
<a name="l00254"></a>00254 {
<a name="l00255"></a>00255   outStream &lt;&lt; <span class="stringliteral">"RollingSampleCounter 0x"</span> &lt;&lt; std::hex
<a name="l00256"></a>00256             &lt;&lt; ((int) <span class="keyword">this</span>) &lt;&lt; std::dec &lt;&lt; std::endl;
<a name="l00257"></a>00257   <span class="keywordtype">char</span> nowString[32];
<a name="l00258"></a>00258   sprintf(nowString, <span class="stringliteral">"%16.4f"</span>, getCurrentTime());
<a name="l00259"></a>00259   outStream &lt;&lt; <span class="stringliteral">"  Now = "</span> &lt;&lt; nowString &lt;&lt; std::endl;
<a name="l00260"></a>00260   outStream &lt;&lt; <span class="stringliteral">"  Window size = "</span> &lt;&lt; windowSize_ &lt;&lt; std::endl;
<a name="l00261"></a>00261   outStream &lt;&lt; <span class="stringliteral">"  Bin size = "</span> &lt;&lt; binSize_ &lt;&lt; std::endl;
<a name="l00262"></a>00262   outStream &lt;&lt; <span class="stringliteral">"  Sample count = "</span> &lt;&lt; sampleCount_ &lt;&lt; std::endl;
<a name="l00263"></a>00263   outStream &lt;&lt; <span class="stringliteral">"  Processed bin count = "</span> &lt;&lt; processedBinCount_ &lt;&lt; std::endl;
<a name="l00264"></a>00264   outStream &lt;&lt; <span class="stringliteral">"  Working index = "</span>
<a name="l00265"></a>00265             &lt;&lt; ((int) (workingBinId_ % binCount_)) &lt;&lt; std::endl;
<a name="l00266"></a>00266   outStream &lt;&lt; <span class="stringliteral">"  Working value = "</span> &lt;&lt; workingBinSum_ &lt;&lt; std::endl;
<a name="l00267"></a>00267   outStream &lt;&lt; <span class="stringliteral">"  Current total = "</span> &lt;&lt; currentTotal_ &lt;&lt; std::endl;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   <span class="keywordtype">char</span> binString[200];
<a name="l00270"></a>00270   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; binCount_; idx++) {
<a name="l00271"></a>00271     sprintf(binString,
<a name="l00272"></a>00272             <span class="stringliteral">"    bin %2d, value %10.2f, startTime %13.2f, stopTime %13.2f"</span>,
<a name="l00273"></a>00273             idx, (*binContents_)[idx], (*binStartTimes_)[idx],
<a name="l00274"></a>00274             (*binStopTimes_)[idx]);
<a name="l00275"></a>00275     outStream &lt;&lt; binString &lt;&lt; std::endl;
<a name="l00276"></a>00276   }
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00283"></a>00283 <span class="keywordtype">void</span> RollingSampleCounter::shuffleBins(<span class="keywordtype">long</span> <span class="keywordtype">long</span> sampleCount)
<a name="l00284"></a>00284 {
<a name="l00285"></a>00285   <span class="comment">// determine the current bin</span>
<a name="l00286"></a>00286   <span class="keywordtype">long</span> <span class="keywordtype">long</span> currentBinId = getBinId(sampleCount);
<a name="l00287"></a>00287   <span class="comment">//std::cout &lt;&lt; "Shuffle " &lt;&lt; workingBinId_ &lt;&lt; " "</span>
<a name="l00288"></a>00288   <span class="comment">//          &lt;&lt; currentBinId &lt;&lt; std::endl;</span>
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="comment">// if we're still working on the current bin, no shuffling is needed</span>
<a name="l00291"></a>00291   <span class="keywordflow">if</span> (currentBinId == workingBinId_) {
<a name="l00292"></a>00292     <span class="keywordflow">return</span>;
<a name="l00293"></a>00293   }
<a name="l00294"></a>00294   ++processedBinCount_;
<a name="l00295"></a>00295   <span class="keywordtype">double</span> now = getCurrentTime();
<a name="l00296"></a>00296 
<a name="l00297"></a>00297   <span class="comment">// handle the different accumulation styles</span>
<a name="l00298"></a>00298   <span class="keywordflow">if</span> (accumStyle_ == INCLUDE_SAMPLES_AFTER_BINNING) {
<a name="l00299"></a>00299 
<a name="l00300"></a>00300     <span class="comment">// move the working bin value into the list</span>
<a name="l00301"></a>00301     <span class="keywordtype">int</span> binIndex = (int) (workingBinId_ % binCount_);
<a name="l00302"></a>00302     currentTotal_ -= (*binContents_)[binIndex];
<a name="l00303"></a>00303     (*binContents_)[binIndex] = workingBinSum_;
<a name="l00304"></a>00304     (*binStartTimes_)[binIndex] = workingBinStartTime_;
<a name="l00305"></a>00305     (*binStopTimes_)[binIndex] = now;
<a name="l00306"></a>00306     currentTotal_ += workingBinSum_;
<a name="l00307"></a>00307     workingBinSum_ = 0.0;
<a name="l00308"></a>00308     workingBinStartTime_ = now;
<a name="l00309"></a>00309   }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   <span class="keywordflow">else</span> {
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="comment">// clear out the current bin value so it's ready for new data</span>
<a name="l00314"></a>00314     <span class="keywordtype">int</span> binIndex = (int) (currentBinId % binCount_);
<a name="l00315"></a>00315     currentTotal_ -= (*binContents_)[binIndex];
<a name="l00316"></a>00316     (*binContents_)[binIndex] = 0.0;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318     <span class="keywordtype">int</span> binIndex2 = (int) (workingBinId_ % binCount_);
<a name="l00319"></a>00319     (*binStartTimes_)[binIndex] = (*binStopTimes_)[binIndex2];
<a name="l00320"></a>00320   }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322   <span class="comment">// update the working bin ID to the current bin</span>
<a name="l00323"></a>00323   workingBinId_ = currentBinId;
<a name="l00324"></a>00324 }
<a name="l00325"></a>00325 
<a name="l00329"></a>00329 <span class="keywordtype">long</span> <span class="keywordtype">long</span> RollingSampleCounter::getBinId(<span class="keywordtype">long</span> <span class="keywordtype">long</span> sampleCount)
<a name="l00330"></a>00330 {
<a name="l00331"></a>00331   <span class="keywordflow">return</span> (<span class="keywordtype">long</span> <span class="keywordtype">long</span>) (sampleCount / (<span class="keywordtype">long</span> long) binSize_);
<a name="l00332"></a>00332 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jan 30 12:00:49 2009 for StorageManager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
