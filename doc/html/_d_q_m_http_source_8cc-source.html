<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>StorageManager: src/DQMHttpSource.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>src/DQMHttpSource.cc</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00008"></a>00008 <span class="preprocessor">#include "EventFilter/StorageManager/src/DQMHttpSource.h"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "EventFilter/StorageManager/interface/SMCurlInterface.h"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "EventFilter/StorageManager/interface/DQMInstance.h"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "FWCore/Utilities/interface/DebugMacros.h"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "FWCore/Framework/interface/Event.h"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "FWCore/ServiceRegistry/interface/Service.h"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "FWCore/Utilities/interface/UnixSignalHandlers.h"</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include "IOPool/Streamer/interface/OtherMessage.h"</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include "IOPool/Streamer/interface/ConsRegMessage.h"</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include "IOPool/Streamer/interface/DQMEventMessage.h"</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include "IOPool/Streamer/interface/StreamDQMDeserializer.h"</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include "DQMServices/Core/interface/DQMStore.h"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include "DQMServices/Core/interface/MonitorElement.h"</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include "TClass.h"</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include "curl/curl.h"</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;wait.h&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="keyword">using namespace </span>edm;
<a name="l00032"></a>00032 <span class="keyword">using namespace </span>std;
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="keyword">namespace </span>edm
<a name="l00035"></a>00035 {  
<a name="l00036"></a>00036   DQMHttpSource::DQMHttpSource(<span class="keyword">const</span> ParameterSet&amp; pset, 
<a name="l00037"></a>00037                                          <span class="keyword">const</span> InputSourceDescription&amp; desc) :
<a name="l00038"></a>00038     edm::RawInputSource(pset,desc), 
<a name="l00039"></a>00039     updatesCounter_(0),
<a name="l00040"></a>00040     sourceurl_(pset.getUntrackedParameter&lt;string&gt;(<span class="stringliteral">"sourceURL"</span>)),
<a name="l00041"></a>00041     buf_(1000*1000*7), 
<a name="l00042"></a>00042     events_read_(0),
<a name="l00043"></a>00043     consumerTopFolderName_(pset.getUntrackedParameter&lt;string&gt;(<span class="stringliteral">"topLevelFolderName"</span>)),
<a name="l00044"></a>00044     alreadySaidHalted_(false)
<a name="l00045"></a>00045   {
<a name="l00046"></a>00046     std::string evturl = sourceurl_ + <span class="stringliteral">"/getDQMeventdata"</span>;
<a name="l00047"></a>00047     <span class="keywordtype">int</span> stlen = evturl.length();
<a name="l00048"></a>00048     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;stlen; i++) DQMeventurl_[i]=evturl[i];
<a name="l00049"></a>00049     DQMeventurl_[stlen] = <span class="charliteral">'\0'</span>;
<a name="l00050"></a>00050 
<a name="l00051"></a>00051     std::string regurl = sourceurl_ + <span class="stringliteral">"/registerDQMConsumer"</span>;
<a name="l00052"></a>00052     stlen = regurl.length();
<a name="l00053"></a>00053     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;stlen; i++) DQMsubscriptionurl_[i]=regurl[i];
<a name="l00054"></a>00054     DQMsubscriptionurl_[stlen] = <span class="charliteral">'\0'</span>;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056     <span class="keyword">const</span> <span class="keywordtype">double</span> MAX_REQUEST_INTERVAL = 300.0;  <span class="comment">// seconds</span>
<a name="l00057"></a>00057     DQMconsumerName_ = pset.getUntrackedParameter&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">"DQMconsumerName"</span>,<span class="stringliteral">"Unknown"</span>);
<a name="l00058"></a>00058     DQMconsumerPriority_ = pset.getUntrackedParameter&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">"DQMconsumerPriority"</span>,<span class="stringliteral">"normal"</span>);
<a name="l00059"></a>00059     headerRetryInterval_ = pset.getUntrackedParameter&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"headerRetryInterval"</span>,5);
<a name="l00060"></a>00060     <span class="keywordtype">double</span> maxEventRequestRate = pset.getUntrackedParameter&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">"maxDQMEventRequestRate"</span>,1.0);
<a name="l00061"></a>00061     <span class="keywordflow">if</span> (maxEventRequestRate &lt; (1.0 / MAX_REQUEST_INTERVAL)) {
<a name="l00062"></a>00062       minDQMEventRequestInterval_ = MAX_REQUEST_INTERVAL;
<a name="l00063"></a>00063     }
<a name="l00064"></a>00064     <span class="keywordflow">else</span> {
<a name="l00065"></a>00065       minDQMEventRequestInterval_ = 1.0 / maxEventRequestRate;  <span class="comment">// seconds</span>
<a name="l00066"></a>00066     }
<a name="l00067"></a>00067     lastDQMRequestTime_.tv_sec = 0;
<a name="l00068"></a>00068     lastDQMRequestTime_.tv_usec = 0;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070     <span class="comment">// register this DQM consumer with the DQMevent server of the Storage Manager</span>
<a name="l00071"></a>00071     DQMconsumerId_ = (time(0) &amp; 0xffffff);  <span class="comment">// temporary - will get from ES later</span>
<a name="l00072"></a>00072     registerWithDQMEventServer();
<a name="l00073"></a>00073     <span class="comment">// when running Async it seems bei_ is not NULL at the start after default ctor</span>
<a name="l00074"></a>00074     bei_ = NULL;
<a name="l00075"></a>00075   }
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 
<a name="l00078"></a>00078   std::auto_ptr&lt;Event&gt; DQMHttpSource::readOneEvent()
<a name="l00079"></a>00079   {
<a name="l00080"></a>00080     <span class="comment">// repeat a http get every X seconds until we get a DQMevent</span>
<a name="l00081"></a>00081     <span class="comment">// only way to stop is specify a maxEvents parameter</span>
<a name="l00082"></a>00082     <span class="comment">// or kill the Storage Manager XDAQ application so the http get fails.</span>
<a name="l00083"></a>00083 
<a name="l00084"></a>00084     <span class="comment">// try to get an event repeat until we get one, this allows</span>
<a name="l00085"></a>00085     <span class="comment">// re-registration is the SM is halted or stopped</span>
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     <span class="keywordtype">bool</span> gotEvent = <span class="keyword">false</span>;
<a name="l00088"></a>00088     std::auto_ptr&lt;Event&gt; result(0);
<a name="l00089"></a>00089     <span class="keywordflow">while</span> ((!gotEvent) &amp;&amp; (!edm::shutdown_flag))
<a name="l00090"></a>00090     { 
<a name="l00091"></a>00091        result = getOneDQMEvent();
<a name="l00092"></a>00092        <span class="keywordflow">if</span>(result.get() != NULL) gotEvent = <span class="keyword">true</span>;
<a name="l00093"></a>00093     } 
<a name="l00094"></a>00094     <span class="keywordflow">return</span> result;
<a name="l00095"></a>00095   }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097   std::auto_ptr&lt;Event&gt; DQMHttpSource::getOneDQMEvent()
<a name="l00098"></a>00098   {
<a name="l00099"></a>00099     <span class="comment">// repeat a http get every X seconds until we get a DQMevent</span>
<a name="l00100"></a>00100     <span class="comment">// only way to stop is specify a maxEvents parameter</span>
<a name="l00101"></a>00101     <span class="comment">// or kill the Storage Manager XDAQ application so the http get fails.</span>
<a name="l00102"></a>00102 
<a name="l00103"></a>00103     <span class="comment">// check if we need to sleep (to enforce the allowed request rate)</span>
<a name="l00104"></a>00104     <span class="keyword">struct </span>timeval now;
<a name="l00105"></a>00105     <span class="keyword">struct </span>timezone dummyTZ;
<a name="l00106"></a>00106     gettimeofday(&amp;now, &amp;dummyTZ);
<a name="l00107"></a>00107     <span class="keywordtype">double</span> timeDiff = (double) now.tv_sec;
<a name="l00108"></a>00108     timeDiff -= (<span class="keywordtype">double</span>) lastDQMRequestTime_.tv_sec;
<a name="l00109"></a>00109     timeDiff += ((double) now.tv_usec / 1000000.0);
<a name="l00110"></a>00110     timeDiff -= ((double) lastDQMRequestTime_.tv_usec / 1000000.0);
<a name="l00111"></a>00111     <span class="keywordflow">if</span> (timeDiff &lt; minDQMEventRequestInterval_)
<a name="l00112"></a>00112     {
<a name="l00113"></a>00113       <span class="keywordtype">double</span> sleepTime = minDQMEventRequestInterval_ - timeDiff;
<a name="l00114"></a>00114       <span class="comment">// trim off a little sleep time to account for the time taken by</span>
<a name="l00115"></a>00115       <span class="comment">// calling gettimeofday again</span>
<a name="l00116"></a>00116       sleepTime -= 0.01;
<a name="l00117"></a>00117       <span class="keywordflow">if</span> (sleepTime &lt; 0.0) {sleepTime = 0.0;}
<a name="l00118"></a>00118       usleep(static_cast&lt;int&gt;(1000000 * sleepTime));
<a name="l00119"></a>00119       gettimeofday(&amp;lastDQMRequestTime_, &amp;dummyTZ);
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121     <span class="keywordflow">else</span>
<a name="l00122"></a>00122     {
<a name="l00123"></a>00123       lastDQMRequestTime_ = now;
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     stor::ReadData data;
<a name="l00127"></a>00127     <span class="keywordtype">bool</span> alreadySaidWaiting = <span class="keyword">false</span>;
<a name="l00128"></a>00128     <span class="keywordflow">do</span> {
<a name="l00129"></a>00129       CURL* han = curl_easy_init();
<a name="l00130"></a>00130 
<a name="l00131"></a>00131       <span class="keywordflow">if</span>(han==0)
<a name="l00132"></a>00132       {
<a name="l00133"></a>00133         cerr &lt;&lt; <span class="stringliteral">"DQMHttpSOurce: could not create handle"</span> &lt;&lt; endl;
<a name="l00134"></a>00134         <span class="keywordflow">throw</span> cms::Exception(<span class="stringliteral">"getOneEvent"</span>,<span class="stringliteral">"DQMHttpSource"</span>)
<a name="l00135"></a>00135             &lt;&lt; <span class="stringliteral">"Unable to create curl handle\n"</span>;
<a name="l00136"></a>00136         <span class="comment">// this will end cmsRun</span>
<a name="l00137"></a>00137       }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139       stor::setopt(han,CURLOPT_URL,DQMeventurl_);
<a name="l00140"></a>00140       stor::setopt(han,CURLOPT_WRITEFUNCTION,stor::func);
<a name="l00141"></a>00141       stor::setopt(han,CURLOPT_WRITEDATA,&amp;data);
<a name="l00142"></a>00142 
<a name="l00143"></a>00143       <span class="comment">// send our consumer ID as part of the event request</span>
<a name="l00144"></a>00144       <span class="keywordtype">char</span> msgBuff[100];
<a name="l00145"></a>00145       OtherMessageBuilder requestMessage(&amp;msgBuff[0], Header::DQMEVENT_REQUEST,
<a name="l00146"></a>00146                                          <span class="keyword">sizeof</span>(char_uint32));
<a name="l00147"></a>00147       uint8 *bodyPtr = requestMessage.msgBody();
<a name="l00148"></a>00148       char_uint32 convertedId;
<a name="l00149"></a>00149       convert(DQMconsumerId_, convertedId);
<a name="l00150"></a>00150       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; <span class="keyword">sizeof</span>(char_uint32); idx++) {
<a name="l00151"></a>00151         bodyPtr[idx] = convertedId[idx];
<a name="l00152"></a>00152       }
<a name="l00153"></a>00153       stor::setopt(han, CURLOPT_POSTFIELDS, requestMessage.startAddress());
<a name="l00154"></a>00154       stor::setopt(han, CURLOPT_POSTFIELDSIZE, requestMessage.size());
<a name="l00155"></a>00155       <span class="keyword">struct </span>curl_slist *headers=NULL;
<a name="l00156"></a>00156       headers = curl_slist_append(headers, <span class="stringliteral">"Content-Type: application/octet-stream"</span>);
<a name="l00157"></a>00157       headers = curl_slist_append(headers, <span class="stringliteral">"Content-Transfer-Encoding: binary"</span>);
<a name="l00158"></a>00158       stor::setopt(han, CURLOPT_HTTPHEADER, headers);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160       <span class="comment">// send the HTTP POST, read the reply, and cleanup before going on</span>
<a name="l00161"></a>00161       CURLcode messageStatus = curl_easy_perform(han);
<a name="l00162"></a>00162       curl_slist_free_all(headers);
<a name="l00163"></a>00163       curl_easy_cleanup(han);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165       <span class="keywordflow">if</span>(messageStatus!=0)
<a name="l00166"></a>00166       {
<a name="l00167"></a>00167         cerr &lt;&lt; <span class="stringliteral">"curl perform failed for DQMevent, messageStatus = "</span>
<a name="l00168"></a>00168              &lt;&lt; messageStatus &lt;&lt; endl;
<a name="l00169"></a>00169         <span class="keywordflow">throw</span> cms::Exception(<span class="stringliteral">"getOneDQMEvent"</span>,<span class="stringliteral">"DQMHttpSource"</span>)
<a name="l00170"></a>00170             &lt;&lt; <span class="stringliteral">"Could not get event: probably XDAQ not running on Storage Manager "</span>
<a name="l00171"></a>00171             &lt;&lt; <span class="stringliteral">"\n"</span>;
<a name="l00172"></a>00172         <span class="comment">// this will end cmsRun</span>
<a name="l00173"></a>00173       }
<a name="l00174"></a>00174       <span class="keywordflow">if</span>(data.d_.length() == 0)
<a name="l00175"></a>00175       {
<a name="l00176"></a>00176         <span class="keywordflow">if</span>(!alreadySaidWaiting) {
<a name="l00177"></a>00177           std::cout &lt;&lt; <span class="stringliteral">"...waiting for DQMevent from Storage Manager..."</span> &lt;&lt; std::endl;
<a name="l00178"></a>00178           alreadySaidWaiting = <span class="keyword">true</span>;
<a name="l00179"></a>00179         }
<a name="l00180"></a>00180         <span class="comment">// sleep for the standard request interval</span>
<a name="l00181"></a>00181         usleep(static_cast&lt;int&gt;(1000000 * minDQMEventRequestInterval_));
<a name="l00182"></a>00182       }
<a name="l00183"></a>00183     } <span class="keywordflow">while</span> (data.d_.length() == 0 &amp;&amp; !edm::shutdown_flag);
<a name="l00184"></a>00184     <span class="keywordflow">if</span> (edm::shutdown_flag) {
<a name="l00185"></a>00185       <span class="keywordflow">return</span> std::auto_ptr&lt;edm::Event&gt;();
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     <span class="keywordtype">int</span> len = data.d_.length();
<a name="l00189"></a>00189     FDEBUG(9) &lt;&lt; <span class="stringliteral">"DQMHttpSource received len = "</span> &lt;&lt; len &lt;&lt; std::endl;
<a name="l00190"></a>00190     buf_.resize(len);
<a name="l00191"></a>00191     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;len ; i++) buf_[i] = data.d_[i];
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     OtherMessageView msgView(&amp;buf_[0]);
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     RunNumber_t iRun = 0;
<a name="l00196"></a>00196     LuminosityBlockNumber_t iLumi = 0;
<a name="l00197"></a>00197     EventNumber_t iEvent = 0;
<a name="l00198"></a>00198     TimeValue_t tStamp = 1;
<a name="l00199"></a>00199     Timestamp timeStamp (tStamp);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="keywordflow">if</span> (msgView.code() == Header::DONE) {
<a name="l00202"></a>00202       <span class="comment">// Continue past run boundaries (SM halt)</span>
<a name="l00203"></a>00203       <span class="comment">// no need to register again as the SM/EventServer is kept alive on a stopAction</span>
<a name="l00204"></a>00204      <span class="keywordflow">if</span>(!alreadySaidHalted_) {
<a name="l00205"></a>00205        alreadySaidHalted_ = <span class="keyword">true</span>;
<a name="l00206"></a>00206        std::cout &lt;&lt; <span class="stringliteral">"Storage Manager has halted - waiting for restart"</span> &lt;&lt; std::endl;
<a name="l00207"></a>00207      }
<a name="l00208"></a>00208      <span class="keywordflow">return</span> std::auto_ptr&lt;edm::Event&gt;();
<a name="l00209"></a>00209     } <span class="keywordflow">else</span> {
<a name="l00210"></a>00210       <span class="comment">// counting the updates</span>
<a name="l00211"></a>00211       ++updatesCounter_;
<a name="l00212"></a>00212       ++events_read_;
<a name="l00213"></a>00213       DQMEventMsgView dqmEventView(&amp;buf_[0]);
<a name="l00214"></a>00214       iRun = dqmEventView.runNumber();
<a name="l00215"></a>00215       iLumi = dqmEventView.lumiSection();
<a name="l00216"></a>00216       iEvent = dqmEventView.eventNumberAtUpdate();
<a name="l00217"></a>00217       timeStamp = dqmEventView.timeStamp();
<a name="l00218"></a>00218 
<a name="l00219"></a>00219       FDEBUG(8) &lt;&lt; <span class="stringliteral">"  DQM Message data:"</span> &lt;&lt; std::endl;
<a name="l00220"></a>00220       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    protocol version = "</span>
<a name="l00221"></a>00221                 &lt;&lt; dqmEventView.protocolVersion() &lt;&lt; std::endl;
<a name="l00222"></a>00222       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    header size = "</span>
<a name="l00223"></a>00223                 &lt;&lt; dqmEventView.headerSize() &lt;&lt; std::endl;
<a name="l00224"></a>00224       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    run number = "</span>
<a name="l00225"></a>00225                 &lt;&lt; dqmEventView.runNumber() &lt;&lt; std::endl;
<a name="l00226"></a>00226       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    event number = "</span>
<a name="l00227"></a>00227                 &lt;&lt; dqmEventView.eventNumberAtUpdate() &lt;&lt; std::endl;
<a name="l00228"></a>00228       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    lumi section = "</span>
<a name="l00229"></a>00229                 &lt;&lt; dqmEventView.lumiSection() &lt;&lt; std::endl;
<a name="l00230"></a>00230       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    update number = "</span>
<a name="l00231"></a>00231                 &lt;&lt; dqmEventView.updateNumber() &lt;&lt; std::endl;
<a name="l00232"></a>00232       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    compression flag = "</span>
<a name="l00233"></a>00233                 &lt;&lt; dqmEventView.compressionFlag() &lt;&lt; std::endl;
<a name="l00234"></a>00234       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    reserved word = "</span>
<a name="l00235"></a>00235                 &lt;&lt; dqmEventView.reserved() &lt;&lt; std::endl;
<a name="l00236"></a>00236       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    release tag = "</span>
<a name="l00237"></a>00237                 &lt;&lt; dqmEventView.releaseTag() &lt;&lt; std::endl;
<a name="l00238"></a>00238       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    top folder name = "</span>
<a name="l00239"></a>00239                 &lt;&lt; dqmEventView.topFolderName() &lt;&lt; std::endl;
<a name="l00240"></a>00240       FDEBUG(8) &lt;&lt; <span class="stringliteral">"    sub folder count = "</span>
<a name="l00241"></a>00241                 &lt;&lt; dqmEventView.subFolderCount() &lt;&lt; std::endl;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243       <span class="comment">// deserialize and stick into DQM backend</span>
<a name="l00244"></a>00244       <span class="comment">// need both types of interfaces as the extractObject I use is</span>
<a name="l00245"></a>00245       <span class="comment">// only in DQMStore</span>
<a name="l00246"></a>00246       <span class="keywordflow">if</span> (bei_ == NULL) {
<a name="l00247"></a>00247         bei_ = edm::Service&lt;DQMStore&gt;().operator-&gt;();
<a name="l00248"></a>00248       }
<a name="l00249"></a>00249       <span class="keywordflow">if</span> (bei_ == NULL) {
<a name="l00250"></a>00250         <span class="keywordflow">throw</span> cms::Exception(<span class="stringliteral">"readOneEvent"</span>, <span class="stringliteral">"DQMHttpSource"</span>)
<a name="l00251"></a>00251           &lt;&lt; <span class="stringliteral">"Unable to lookup the DQMStore service!\n"</span>;
<a name="l00252"></a>00252       }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254       edm::StreamDQMDeserializer deserializeWorker;
<a name="l00255"></a>00255       std::auto_ptr&lt;DQMEvent::TObjectTable&gt; toTablePtr =
<a name="l00256"></a>00256           deserializeWorker.deserializeDQMEvent(dqmEventView);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = 0;
<a name="l00259"></a>00259       DQMEvent::TObjectTable::const_iterator toIter;
<a name="l00260"></a>00260       <span class="keywordflow">for</span> (toIter = toTablePtr-&gt;begin();
<a name="l00261"></a>00261            toIter != toTablePtr-&gt;end(); toIter++) {
<a name="l00262"></a>00262         std::string subFolderName = toIter-&gt;first;
<a name="l00263"></a>00263         std::vector&lt;TObject *&gt; toList = toIter-&gt;second;
<a name="l00264"></a>00264         bei_-&gt;makeDirectory(subFolderName);  <span class="comment">// fetch or create</span>
<a name="l00265"></a>00265         bei_-&gt;setCurrentFolder(subFolderName);
<a name="l00266"></a>00266         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tdx = 0; tdx &lt; (int) toList.size(); tdx++) {
<a name="l00267"></a>00267           TObject *toPtr = toList[tdx];
<a name="l00268"></a>00268           std::string cls = toPtr-&gt;IsA()-&gt;GetName();
<a name="l00269"></a>00269           std::string nm = stor::DQMInstance::getSafeMEName(toPtr);
<a name="l00270"></a>00270           FDEBUG(8) &lt;&lt; <span class="stringliteral">"    TObject class = "</span> &lt;&lt; cls &lt;&lt; <span class="stringliteral">", name = "</span> &lt;&lt; nm &lt;&lt; std::endl;
<a name="l00271"></a>00271           <span class="keywordflow">if</span> (bei_-&gt;extract(toPtr, bei_-&gt;pwd(), <span class="keyword">true</span>))
<a name="l00272"></a>00272           {
<a name="l00273"></a>00273             std::string path;
<a name="l00274"></a>00274             <span class="keywordflow">if</span> (MonitorElement *me = bei_-&gt;findObject(subFolderName, nm, path))
<a name="l00275"></a>00275               me-&gt;update();
<a name="l00276"></a>00276             ++count;
<a name="l00277"></a>00277           }
<a name="l00278"></a>00278         }
<a name="l00279"></a>00279       }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281       <span class="comment">// clean up memory by spinning through the DQMEvent::TObjectTable map and</span>
<a name="l00282"></a>00282       <span class="comment">// deleting each TObject in the std::vector&lt;TObject *&gt; later we will</span>
<a name="l00283"></a>00283       <span class="comment">// change map to use std::vector&lt; boost::shared_ptr&lt;TObject&gt; &gt;</span>
<a name="l00284"></a>00284       DQMEvent::TObjectTable::iterator ti(toTablePtr-&gt;begin()), te(toTablePtr-&gt;end());
<a name="l00285"></a>00285       <span class="keywordflow">for</span> ( ; ti != te; ++ti) {
<a name="l00286"></a>00286         std::string subFolderName = ti-&gt;first;
<a name="l00287"></a>00287         std::vector&lt;TObject *&gt;::iterator vi(ti-&gt;second.begin()), ve(ti-&gt;second.end());
<a name="l00288"></a>00288         <span class="keywordflow">for</span> ( ; vi != ve; ++vi) {
<a name="l00289"></a>00289           std::string histoName = stor::DQMInstance::getSafeMEName(*vi);
<a name="l00290"></a>00290           std::string fullName = subFolderName + <span class="stringliteral">"/"</span> + histoName;
<a name="l00291"></a>00291           std::vector&lt;std::string&gt;::iterator entryFound;
<a name="l00292"></a>00292           entryFound = std::find(firstHistoExtractDone_.begin(),
<a name="l00293"></a>00293                                  firstHistoExtractDone_.end(),
<a name="l00294"></a>00294                                  fullName);
<a name="l00295"></a>00295           <span class="comment">// 30-May-2008, KAB - skip over deleting the memory of the first</span>
<a name="l00296"></a>00296           <span class="comment">// ME passed to bei_-&gt;extract() until we check into having that</span>
<a name="l00297"></a>00297           <span class="comment">// code copy the ME instead of using it directly.</span>
<a name="l00298"></a>00298           <span class="keywordflow">if</span> (entryFound == firstHistoExtractDone_.end()) {
<a name="l00299"></a>00299             firstHistoExtractDone_.push_back(fullName);
<a name="l00300"></a>00300           }
<a name="l00301"></a>00301           <span class="keywordflow">else</span> {
<a name="l00302"></a>00302             <span class="keyword">delete</span> *vi;
<a name="l00303"></a>00303           }
<a name="l00304"></a>00304         }
<a name="l00305"></a>00305       }
<a name="l00306"></a>00306     }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     EventID eventId(iRun,iEvent);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="comment">// make a fake event containing no data but the evId and runId from DQMEvent</span>
<a name="l00311"></a>00311     <span class="comment">// and the time stamp from the event at update</span>
<a name="l00312"></a>00312     std::auto_ptr&lt;Event&gt; e = makeEvent(iRun,iLumi,iEvent,timeStamp);
<a name="l00313"></a>00313 
<a name="l00314"></a>00314     <span class="keywordflow">return</span> e;
<a name="l00315"></a>00315   }
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   <span class="keywordtype">void</span> DQMHttpSource::registerWithDQMEventServer()
<a name="l00318"></a>00318   {
<a name="l00319"></a>00319     stor::ReadData data;
<a name="l00320"></a>00320     uint32 registrationStatus;
<a name="l00321"></a>00321     <span class="keywordtype">bool</span> alreadySaidWaiting = <span class="keyword">false</span>;
<a name="l00322"></a>00322     <span class="keywordflow">do</span> {
<a name="l00323"></a>00323       data.d_.clear();
<a name="l00324"></a>00324       CURL* han = curl_easy_init();
<a name="l00325"></a>00325       <span class="keywordflow">if</span>(han==0)
<a name="l00326"></a>00326         {
<a name="l00327"></a>00327           cerr &lt;&lt; <span class="stringliteral">"could not create handle"</span> &lt;&lt; endl;
<a name="l00328"></a>00328           <span class="keywordflow">throw</span> cms::Exception(<span class="stringliteral">"registerWithDQMEventServer"</span>,<span class="stringliteral">"DQMHttpSource"</span>)
<a name="l00329"></a>00329             &lt;&lt; <span class="stringliteral">"Unable to create curl handle\n"</span>;
<a name="l00330"></a>00330         }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332       <span class="comment">// set the standard http request options</span>
<a name="l00333"></a>00333       stor::setopt(han,CURLOPT_URL,DQMsubscriptionurl_);
<a name="l00334"></a>00334       stor::setopt(han,CURLOPT_WRITEFUNCTION,stor::func);
<a name="l00335"></a>00335       stor::setopt(han,CURLOPT_WRITEDATA,&amp;data);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337       <span class="comment">// build the registration request message to send to the storage manager</span>
<a name="l00338"></a>00338       <span class="keyword">const</span> <span class="keywordtype">int</span> BUFFER_SIZE = 2000;
<a name="l00339"></a>00339       <span class="keywordtype">char</span> msgBuff[BUFFER_SIZE];
<a name="l00340"></a>00340       ConsRegRequestBuilder requestMessage(msgBuff, BUFFER_SIZE, DQMconsumerName_,
<a name="l00341"></a>00341                                        DQMconsumerPriority_, consumerTopFolderName_);
<a name="l00342"></a>00342 
<a name="l00343"></a>00343       <span class="comment">// add the request message as a http post</span>
<a name="l00344"></a>00344       stor::setopt(han, CURLOPT_POSTFIELDS, requestMessage.startAddress());
<a name="l00345"></a>00345       stor::setopt(han, CURLOPT_POSTFIELDSIZE, requestMessage.size());
<a name="l00346"></a>00346       <span class="keyword">struct </span>curl_slist *headers=NULL;
<a name="l00347"></a>00347       headers = curl_slist_append(headers, <span class="stringliteral">"Content-Type: application/octet-stream"</span>);
<a name="l00348"></a>00348       headers = curl_slist_append(headers, <span class="stringliteral">"Content-Transfer-Encoding: binary"</span>);
<a name="l00349"></a>00349       stor::setopt(han, CURLOPT_HTTPHEADER, headers);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351       <span class="comment">// send the HTTP POST, read the reply, and cleanup before going on</span>
<a name="l00352"></a>00352       CURLcode messageStatus = curl_easy_perform(han);
<a name="l00353"></a>00353       curl_slist_free_all(headers);
<a name="l00354"></a>00354       curl_easy_cleanup(han);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356       <span class="keywordflow">if</span>(messageStatus!=0)
<a name="l00357"></a>00357       {
<a name="l00358"></a>00358         cerr &lt;&lt; <span class="stringliteral">"curl perform failed for DQM registration"</span> &lt;&lt; endl;
<a name="l00359"></a>00359         <span class="keywordflow">throw</span> cms::Exception(<span class="stringliteral">"registerWithDQMEventServer"</span>,<span class="stringliteral">"DQMHttpSource"</span>)
<a name="l00360"></a>00360           &lt;&lt; <span class="stringliteral">"Could not register: probably XDAQ not running or no Storage Manager/SMProxyServer loaded"</span>
<a name="l00361"></a>00361           &lt;&lt; <span class="stringliteral">"\n"</span>;
<a name="l00362"></a>00362       }
<a name="l00363"></a>00363       registrationStatus = ConsRegResponseBuilder::ES_NOT_READY;
<a name="l00364"></a>00364       <span class="keywordflow">if</span>(data.d_.length() &gt; 0)
<a name="l00365"></a>00365       {
<a name="l00366"></a>00366         <span class="keywordtype">int</span> len = data.d_.length();
<a name="l00367"></a>00367         FDEBUG(9) &lt;&lt; <span class="stringliteral">"DQMHttpSource received len = "</span> &lt;&lt; len &lt;&lt; std::endl;
<a name="l00368"></a>00368         buf_.resize(len);
<a name="l00369"></a>00369         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;len ; i++) buf_[i] = data.d_[i];
<a name="l00370"></a>00370 
<a name="l00371"></a>00371         <span class="keywordflow">try</span> {
<a name="l00372"></a>00372           ConsRegResponseView respView(&amp;buf_[0]);
<a name="l00373"></a>00373           registrationStatus = respView.getStatus();
<a name="l00374"></a>00374           DQMconsumerId_ = respView.getConsumerId();
<a name="l00375"></a>00375         }
<a name="l00376"></a>00376         <span class="keywordflow">catch</span> (cms::Exception excpt) {
<a name="l00377"></a>00377           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAX_DUMP_LENGTH = 1000;
<a name="l00378"></a>00378           std::cout &lt;&lt; <span class="stringliteral">"========================================"</span> &lt;&lt; std::endl;
<a name="l00379"></a>00379           std::cout &lt;&lt; <span class="stringliteral">"* Exception decoding the registerWithEventServer response!"</span> &lt;&lt; std::endl;
<a name="l00380"></a>00380           <span class="keywordflow">if</span> (data.d_.length() &lt;= MAX_DUMP_LENGTH) {
<a name="l00381"></a>00381             std::cout &lt;&lt; <span class="stringliteral">"* Here is the raw text that was returned:"</span> &lt;&lt; std::endl;
<a name="l00382"></a>00382             std::cout &lt;&lt; data.d_ &lt;&lt; std::endl;
<a name="l00383"></a>00383           }
<a name="l00384"></a>00384           <span class="keywordflow">else</span> {
<a name="l00385"></a>00385             std::cout &lt;&lt; <span class="stringliteral">"* Here are the first "</span> &lt;&lt; MAX_DUMP_LENGTH &lt;&lt;
<a name="l00386"></a>00386               <span class="stringliteral">" characters of the raw text that was returned:"</span> &lt;&lt; std::endl;
<a name="l00387"></a>00387             std::cout &lt;&lt; (data.d_.substr(0, MAX_DUMP_LENGTH)) &lt;&lt; std::endl;
<a name="l00388"></a>00388           }
<a name="l00389"></a>00389           std::cout &lt;&lt; <span class="stringliteral">"========================================"</span> &lt;&lt; std::endl;
<a name="l00390"></a>00390           <span class="keywordflow">throw</span> excpt;
<a name="l00391"></a>00391         }
<a name="l00392"></a>00392       }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394       <span class="keywordflow">if</span> (registrationStatus == ConsRegResponseBuilder::ES_NOT_READY)
<a name="l00395"></a>00395       {
<a name="l00396"></a>00396         <span class="keywordflow">if</span>(!alreadySaidWaiting) {
<a name="l00397"></a>00397           std::cout &lt;&lt; <span class="stringliteral">"...waiting for DQM registration response from StorageManager or SMProxyServer..."</span> 
<a name="l00398"></a>00398                     &lt;&lt; std::endl;
<a name="l00399"></a>00399           alreadySaidWaiting = <span class="keyword">true</span>;
<a name="l00400"></a>00400         }
<a name="l00401"></a>00401         <span class="comment">// sleep for desired amount of time</span>
<a name="l00402"></a>00402         sleep(headerRetryInterval_);
<a name="l00403"></a>00403       }
<a name="l00404"></a>00404     } <span class="keywordflow">while</span> (registrationStatus == ConsRegResponseBuilder::ES_NOT_READY &amp;&amp;
<a name="l00405"></a>00405              !edm::shutdown_flag);
<a name="l00406"></a>00406 
<a name="l00407"></a>00407     FDEBUG(9) &lt;&lt; <span class="stringliteral">"Consumer ID = "</span> &lt;&lt; DQMconsumerId_ &lt;&lt; endl;
<a name="l00408"></a>00408   }
<a name="l00409"></a>00409 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jan 30 12:00:41 2009 for StorageManager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
